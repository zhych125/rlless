//! Input state machine for handling keyboard events
//!
//! This module implements a minimal state machine that processes keyboard input
//! and generates actions for the application. It focuses only on essential less commands.

use ratatui::crossterm::event::{KeyCode, KeyEvent, KeyEventKind};

/// Current input state
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum InputState {
    /// Normal navigation mode - handles j/k/space/q etc.
    Navigation,
    /// Typing search pattern after pressing '/' or '?'
    SearchInput { direction: SearchDirection },
}

/// Search direction for forward/backward search
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SearchDirection {
    Forward,  // /
    Backward, // ?
}

impl SearchDirection {
    /// Get the character that represents this direction
    pub fn to_char(self) -> char {
        match self {
            SearchDirection::Forward => '/',
            SearchDirection::Backward => '?',
        }
    }
}

/// Actions generated by the state machine
#[derive(Debug, Clone, PartialEq)]
pub enum InputAction {
    // Navigation actions (immediate viewport changes)
    ScrollUp(u64),
    ScrollDown(u64),
    PageUp,
    PageDown,
    GoToStart,
    GoToEnd,
    Quit,

    // Search actions
    StartSearch(SearchDirection),
    UpdateSearchBuffer {
        direction: SearchDirection,
        buffer: String,
    },
    CancelSearch,
    ExecuteSearch {
        pattern: String,
        direction: SearchDirection,
    },
    NextMatch,
    PreviousMatch,

    // State management
    NoAction,
    InvalidInput,
}

/// State machine for processing input events
pub struct InputStateMachine {
    state: InputState,
    search_buffer: String,
}

impl InputStateMachine {
    /// Create a new state machine in navigation mode
    pub fn new() -> Self {
        Self {
            state: InputState::Navigation,
            search_buffer: String::new(),
        }
    }

    /// Process crossterm KeyEvent and return action + update internal state
    pub fn handle_key_event(&mut self, key_event: KeyEvent) -> InputAction {
        // Only handle key press events (ignore release/repeat to avoid double events on Windows)
        if key_event.kind != KeyEventKind::Press {
            return InputAction::NoAction;
        }

        match (self.state, key_event.code) {
            // NAVIGATION STATE - Essential less commands only
            (InputState::Navigation, KeyCode::Char('j')) => InputAction::ScrollDown(1),
            (InputState::Navigation, KeyCode::Down) => InputAction::ScrollDown(1),
            (InputState::Navigation, KeyCode::Char('k')) => InputAction::ScrollUp(1),
            (InputState::Navigation, KeyCode::Up) => InputAction::ScrollUp(1),
            (InputState::Navigation, KeyCode::Char(' ')) => InputAction::PageDown,
            (InputState::Navigation, KeyCode::Char('f')) => InputAction::PageDown,
            (InputState::Navigation, KeyCode::PageDown) => InputAction::PageDown,
            (InputState::Navigation, KeyCode::Char('b')) => InputAction::PageUp,
            (InputState::Navigation, KeyCode::PageUp) => InputAction::PageUp,
            (InputState::Navigation, KeyCode::Char('g')) => InputAction::GoToStart,
            (InputState::Navigation, KeyCode::Char('G')) => InputAction::GoToEnd,
            (InputState::Navigation, KeyCode::Char('q')) => InputAction::Quit,
            (InputState::Navigation, KeyCode::Char('n')) => InputAction::NextMatch,
            (InputState::Navigation, KeyCode::Char('N')) => InputAction::PreviousMatch,

            // Enter search modes
            (InputState::Navigation, KeyCode::Char('/')) => {
                self.state = InputState::SearchInput {
                    direction: SearchDirection::Forward,
                };
                self.search_buffer.clear();
                InputAction::StartSearch(SearchDirection::Forward)
            }
            (InputState::Navigation, KeyCode::Char('?')) => {
                self.state = InputState::SearchInput {
                    direction: SearchDirection::Backward,
                };
                self.search_buffer.clear();
                InputAction::StartSearch(SearchDirection::Backward)
            }

            // SEARCH INPUT STATE
            (InputState::SearchInput { direction }, KeyCode::Char(ch))
                if ch.is_ascii_graphic() || ch == ' ' =>
            {
                self.search_buffer.push(ch);
                InputAction::UpdateSearchBuffer {
                    direction,
                    buffer: self.search_buffer.clone(),
                }
            }
            (InputState::SearchInput { direction }, KeyCode::Backspace) => {
                self.search_buffer.pop();
                InputAction::UpdateSearchBuffer {
                    direction,
                    buffer: self.search_buffer.clone(),
                }
            }
            (InputState::SearchInput { direction }, KeyCode::Enter) => {
                let pattern = self.search_buffer.clone();
                self.state = InputState::Navigation;
                self.search_buffer.clear();
                InputAction::ExecuteSearch { pattern, direction }
            }
            (InputState::SearchInput { direction: _ }, KeyCode::Esc) => {
                self.state = InputState::Navigation;
                self.search_buffer.clear();
                InputAction::CancelSearch
            }

            // Invalid/unhandled input
            _ => InputAction::InvalidInput,
        }
    }

    /// Get current search buffer (for display in status line)
    pub fn get_search_buffer(&self) -> &str {
        &self.search_buffer
    }

    /// Get current state
    pub fn get_state(&self) -> InputState {
        self.state
    }
}

impl Default for InputStateMachine {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_navigation() {
        let mut sm = InputStateMachine::new();

        // Helper to create key press events
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Test basic navigation
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('j'))),
            InputAction::ScrollDown(1)
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('k'))),
            InputAction::ScrollUp(1)
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char(' '))),
            InputAction::PageDown
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('b'))),
            InputAction::PageUp
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('g'))),
            InputAction::GoToStart
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('G'))),
            InputAction::GoToEnd
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('q'))),
            InputAction::Quit
        );
    }

    #[test]
    fn test_forward_search_flow() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Enter forward search mode
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('/'))),
            InputAction::StartSearch(SearchDirection::Forward)
        );
        assert_eq!(
            sm.get_state(),
            InputState::SearchInput {
                direction: SearchDirection::Forward
            }
        );

        // Type search pattern
        sm.handle_key_event(key_press(KeyCode::Char('t')));
        sm.handle_key_event(key_press(KeyCode::Char('e')));
        sm.handle_key_event(key_press(KeyCode::Char('s')));
        sm.handle_key_event(key_press(KeyCode::Char('t')));
        assert_eq!(sm.get_search_buffer(), "test");

        // Execute forward search
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Enter)),
            InputAction::ExecuteSearch {
                pattern: "test".to_string(),
                direction: SearchDirection::Forward
            }
        );
        assert_eq!(sm.get_state(), InputState::Navigation);
    }

    #[test]
    fn test_backward_search_flow() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Enter backward search mode
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('?'))),
            InputAction::StartSearch(SearchDirection::Backward)
        );
        assert_eq!(
            sm.get_state(),
            InputState::SearchInput {
                direction: SearchDirection::Backward
            }
        );

        // Type and execute backward search
        sm.handle_key_event(key_press(KeyCode::Char('f')));
        sm.handle_key_event(key_press(KeyCode::Char('o')));
        sm.handle_key_event(key_press(KeyCode::Char('o')));
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Enter)),
            InputAction::ExecuteSearch {
                pattern: "foo".to_string(),
                direction: SearchDirection::Backward
            }
        );
    }

    #[test]
    fn test_search_escape() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Enter search mode and type something
        sm.handle_key_event(key_press(KeyCode::Char('/')));
        sm.handle_key_event(key_press(KeyCode::Char('t')));
        sm.handle_key_event(key_press(KeyCode::Char('e')));
        assert_eq!(sm.get_search_buffer(), "te");

        // Escape should cancel search and clear buffer
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Esc)),
            InputAction::CancelSearch
        );
        assert_eq!(sm.get_state(), InputState::Navigation);
        assert_eq!(sm.get_search_buffer(), "");
    }

    #[test]
    fn test_search_backspace() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Enter search mode and type something
        sm.handle_key_event(key_press(KeyCode::Char('/')));
        sm.handle_key_event(key_press(KeyCode::Char('t')));
        sm.handle_key_event(key_press(KeyCode::Char('e')));
        sm.handle_key_event(key_press(KeyCode::Char('s')));
        sm.handle_key_event(key_press(KeyCode::Char('t')));
        assert_eq!(sm.get_search_buffer(), "test");

        // Backspace should remove last character
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Backspace)),
            InputAction::UpdateSearchBuffer {
                direction: SearchDirection::Forward,
                buffer: "tes".to_string()
            }
        );
        assert_eq!(sm.get_search_buffer(), "tes");
    }

    #[test]
    fn test_arrow_keys() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Up)),
            InputAction::ScrollUp(1)
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Down)),
            InputAction::ScrollDown(1)
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::PageUp)),
            InputAction::PageUp
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::PageDown)),
            InputAction::PageDown
        );
    }

    #[test]
    fn test_invalid_input() {
        let mut sm = InputStateMachine::new();
        let key_press = |code| KeyEvent::new(code, ratatui::crossterm::event::KeyModifiers::NONE);

        // Invalid keys in navigation mode
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('x'))),
            InputAction::InvalidInput
        );
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Char('z'))),
            InputAction::InvalidInput
        );

        // Invalid keys in search mode (control characters)
        sm.handle_key_event(key_press(KeyCode::Char('/')));
        assert_eq!(
            sm.handle_key_event(key_press(KeyCode::Tab)),
            InputAction::InvalidInput
        );
    }

    #[test]
    fn test_search_direction_chars() {
        assert_eq!(SearchDirection::Forward.to_char(), '/');
        assert_eq!(SearchDirection::Backward.to_char(), '?');
    }
}
