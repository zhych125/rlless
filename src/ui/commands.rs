//! UI command patterns for event-driven architecture
//!
//! This module defines the command pattern used to decouple UI events from application logic.
//! Commands are generated by the UI renderer and processed by the application layer.

use std::path::PathBuf;

/// High-level commands that the UI can generate
#[derive(Debug, Clone, PartialEq)]
pub enum UICommand {
    Navigation(NavigationCommand),
    Search(SearchCommand),
    Display(DisplayCommand),
    File(FileCommand),
    Quit,
}

/// Navigation commands for moving through the file
#[derive(Debug, Clone, PartialEq)]
pub enum NavigationCommand {
    LineUp(u64),      // k, up arrow
    LineDown(u64),    // j, down arrow
    PageUp,           // b, Page Up
    PageDown,         // space, Page Down
    HalfPageUp,       // u
    HalfPageDown,     // d
    GoToStart,        // g, Home
    GoToEnd,          // G, End
    GoToLine(u64),    // [number]G
    FollowMode(bool), // F (toggle follow/tail mode)
}

/// Search-related commands
#[derive(Debug, Clone, PartialEq)]
pub enum SearchCommand {
    StartSearch(SearchDirection), // /, ?
    SearchPattern(String),        // User enters pattern
    NextMatch,                    // n
    PreviousMatch,                // N
    ClearSearch,                  // ESC in search mode
    ToggleHighlight,              // Toggle match highlighting
}

/// Display modification commands
#[derive(Debug, Clone, PartialEq)]
pub enum DisplayCommand {
    ToggleLineNumbers, // -N flag equivalent
    ToggleWordWrap,    // -S flag equivalent
    SetTabWidth(u8),   // Tab width adjustment
    Refresh,           // Ctrl-L
    ShowHelp,          // h
    ShowFileInfo,      // = (show file info)
}

/// File operation commands
#[derive(Debug, Clone, PartialEq)]
pub enum FileCommand {
    OpenFile(PathBuf), // :e filename
    ReloadFile,        // :r or R
    SavePosition,      // Mark position
    RestorePosition,   // Return to mark
}

/// Search direction for forward/backward search
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SearchDirection {
    Forward,
    Backward,
}

impl NavigationCommand {
    /// Get the number of lines to move, if applicable
    pub fn line_count(&self) -> Option<u64> {
        match self {
            NavigationCommand::LineUp(n) | NavigationCommand::LineDown(n) => Some(*n),
            NavigationCommand::GoToLine(n) => Some(*n),
            _ => None,
        }
    }

    /// Check if this is a vertical movement command
    pub fn is_vertical_movement(&self) -> bool {
        matches!(
            self,
            NavigationCommand::LineUp(_)
                | NavigationCommand::LineDown(_)
                | NavigationCommand::PageUp
                | NavigationCommand::PageDown
                | NavigationCommand::HalfPageUp
                | NavigationCommand::HalfPageDown
                | NavigationCommand::GoToStart
                | NavigationCommand::GoToEnd
                | NavigationCommand::GoToLine(_)
        )
    }
}

impl SearchCommand {
    /// Check if this command starts a new search
    pub fn starts_search(&self) -> bool {
        matches!(
            self,
            SearchCommand::StartSearch(_) | SearchCommand::SearchPattern(_)
        )
    }

    /// Check if this command navigates between existing matches
    pub fn is_navigation(&self) -> bool {
        matches!(
            self,
            SearchCommand::NextMatch | SearchCommand::PreviousMatch
        )
    }
}

impl DisplayCommand {
    /// Check if this command affects the viewport layout
    pub fn affects_layout(&self) -> bool {
        matches!(
            self,
            DisplayCommand::ToggleLineNumbers
                | DisplayCommand::ToggleWordWrap
                | DisplayCommand::SetTabWidth(_)
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_navigation_command_line_count() {
        assert_eq!(NavigationCommand::LineUp(5).line_count(), Some(5));
        assert_eq!(NavigationCommand::LineDown(3).line_count(), Some(3));
        assert_eq!(NavigationCommand::GoToLine(100).line_count(), Some(100));
        assert_eq!(NavigationCommand::PageUp.line_count(), None);
    }

    #[test]
    fn test_navigation_command_is_vertical() {
        assert!(NavigationCommand::LineUp(1).is_vertical_movement());
        assert!(NavigationCommand::LineDown(1).is_vertical_movement());
        assert!(NavigationCommand::PageUp.is_vertical_movement());
        assert!(NavigationCommand::GoToStart.is_vertical_movement());
        assert!(!NavigationCommand::FollowMode(true).is_vertical_movement());
    }

    #[test]
    fn test_search_command_categorization() {
        assert!(SearchCommand::StartSearch(SearchDirection::Forward).starts_search());
        assert!(SearchCommand::SearchPattern("test".to_string()).starts_search());
        assert!(!SearchCommand::NextMatch.starts_search());

        assert!(SearchCommand::NextMatch.is_navigation());
        assert!(SearchCommand::PreviousMatch.is_navigation());
        assert!(!SearchCommand::StartSearch(SearchDirection::Forward).is_navigation());
    }

    #[test]
    fn test_display_command_affects_layout() {
        assert!(DisplayCommand::ToggleLineNumbers.affects_layout());
        assert!(DisplayCommand::ToggleWordWrap.affects_layout());
        assert!(DisplayCommand::SetTabWidth(4).affects_layout());
        assert!(!DisplayCommand::ShowHelp.affects_layout());
        assert!(!DisplayCommand::Refresh.affects_layout());
    }

    #[test]
    fn test_command_equality() {
        let cmd1 = UICommand::Navigation(NavigationCommand::LineDown(1));
        let cmd2 = UICommand::Navigation(NavigationCommand::LineDown(1));
        let cmd3 = UICommand::Navigation(NavigationCommand::LineUp(1));

        assert_eq!(cmd1, cmd2);
        assert_ne!(cmd1, cmd3);
    }

    #[test]
    fn test_search_direction() {
        assert_eq!(SearchDirection::Forward, SearchDirection::Forward);
        assert_ne!(SearchDirection::Forward, SearchDirection::Backward);
    }
}
